/*
 * generated by Xtext 2.10.0
 */
package at.jku.weiner.mttf.validation

import at.jku.weiner.mttf.mttf.MttfPackage
import at.jku.weiner.mttf.mttf.SourceMetaModel
import at.jku.weiner.mttf.mttf.TransformationUnderTest
import at.jku.weiner.mttf.mttf.TargetMetaModel
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.validation.Check
import java.util.HashMap
import java.io.IOException
import at.jku.weiner.mttf.utils.ResourceSetUtils
import at.jku.weiner.mttf.extensionpoints.TransformationRegistry

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MttfValidator extends AbstractMttfValidator {
	
	public static val SOURCE_MM_IS_EMPTY = 'sourceMetamodelIsEmpty';
	public static val MSG_SOURCE_MM_IS_EMTPY = 'Source metamodel uri is empty!'
	public static val SOURCE_MM_IS_INVALID = 'sourceMetamodelIsInvalid';
	public static val MSG_SOURCE_MM_IS_INVALID = 'Source metamodel uri is invalid'
	public static val TARGET_MM_IS_EMPTY = 'targetMetamodelIsEmpty';
	public static val MSG_TARGET_MM_IS_EMTPY = 'target metamodel uri is empty!'
	public static val TARGET_MM_IS_INVALID = 'targetMetamodelIsInvalid';
	public static val MSG_TARGET_MM_IS_INVALID = 'Target metamodel uri is invalid'
	public static val TRAFO_IS_EMPTY = 'transformationIsEmpty';
	public static val MSG_TRAFO_IS_EMTPY = 'Transformation (under test) uri is empty!'
	public static val TRAFO_IS_INVALID = 'transformationIsInvalid';
	public static val MSG_TRAFO_IS_INVALID = 'Transformation (under test) uri is not a valid transformation!'
	
	
	def checkNotEmpty(String uriAsString, String id, EStructuralFeature feature, String msg) {
		if ((uriAsString == null) || (uriAsString.isEmpty())) {
			error(msg, feature, id);
			return false;
		}
		return true;
	}
	
	def checkValidMetamodel(String uriAsString, String id, EStructuralFeature feature, String msg) {
		try {
			ResourceSetUtils.getInstance().loadResourceWithoutHandling(uriAsString);
		}
		catch (IOException ex) {
			val errorMsg = msg + "'" + uriAsString + "' ('" + ex.getMessage() + "')!";
			error(errorMsg, feature, id);
			return false;
		}
		return true;
	}
	
	@Check
	def checkSourceMetamodelIsAValidFile(SourceMetaModel sourceMetaModel) {
		val uriAsString = sourceMetaModel.uri;
		if (!checkNotEmpty(uriAsString,
			SOURCE_MM_IS_EMPTY, 
			MttfPackage.Literals.SOURCE_META_MODEL__URI, 
			MSG_SOURCE_MM_IS_EMTPY
		)) {
			return;
		}
		checkValidMetamodel(uriAsString,
			SOURCE_MM_IS_INVALID,
			MttfPackage.Literals.SOURCE_META_MODEL__URI, 
			MSG_SOURCE_MM_IS_INVALID
		)
	}
	
	@Check
	def checkTargetMetamodelIsAValidFile(TargetMetaModel targetMetaModel) {
		val uriAsString = targetMetaModel.uri;
		if (!checkNotEmpty(uriAsString,
			TARGET_MM_IS_EMPTY, 
			MttfPackage.Literals.TARGET_META_MODEL__URI, 
			MSG_TARGET_MM_IS_EMTPY
		)) {
			return;
		}
		checkValidMetamodel(uriAsString,
			TARGET_MM_IS_INVALID,
			MttfPackage.Literals.TARGET_META_MODEL__URI, 
			MSG_TARGET_MM_IS_INVALID
		)
	}
	
	@Check
	def checkTransformationIsAValidFile(TransformationUnderTest transformation) {
		val uriAsString = transformation.uri;
		if (!checkNotEmpty(uriAsString,
			TRAFO_IS_EMPTY, 
			MttfPackage.Literals.TRANSFORMATION_UNDER_TEST__URI, 
			MSG_TRAFO_IS_EMTPY
		)) {
			return;
		}
		val isValid = TransformationRegistry.isValidTransformation(uriAsString);
		if (!isValid) {
			error(MSG_TRAFO_IS_INVALID, MttfPackage.Literals.TRANSFORMATION_UNDER_TEST__URI,
				TRAFO_IS_INVALID
			);
		}
	}
	
}
